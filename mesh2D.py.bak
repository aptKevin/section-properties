'''
The mesh2D module contains the triMesh class, which provides the definitions
for analysis and post-processing at global mesh level, and also the alogorithm
used to compute the plastic centroid.
'''

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import time
import elementDefinitions
import femFunctions


class triMesh:
    '''
    Contains elements within the triangular mesh and computes and
    stores section properties.
    '''

    def __init__(self, genMesh, nu=0, geometricMesh=None):
        '''
        Initialise method takes the mesh object generated by meshpy (genMesh),
        the poisson's ratio (nu) and optionally a triMesh object
        (geometricMesh) containing geometric section properties results.
        '''
        triElements = []  # list holding all element objects
        pointArray = np.array(genMesh.points)  # save points to np array
        elementArray = np.array(genMesh.elements)  # save elements to np array
        # swap mid-node order to retain node ordering consistency
        elementArray[:, [3, 4, 5]] = elementArray[:, [5, 3, 4]]

        # build the mesh one element at a time
        for tri in elementArray:
            x1 = pointArray[tri[0]][0]
            y1 = pointArray[tri[0]][1]
            x2 = pointArray[tri[1]][0]
            y2 = pointArray[tri[1]][1]
            x3 = pointArray[tri[2]][0]
            y3 = pointArray[tri[2]][1]
            x4 = pointArray[tri[3]][0]
            y4 = pointArray[tri[3]][1]
            x5 = pointArray[tri[4]][0]
            y5 = pointArray[tri[4]][1]
            x6 = pointArray[tri[5]][0]
            y6 = pointArray[tri[5]][1]
            # populate the vertices
            vertices = (np.array([[x1, x2, x3, x4, x5, x6],
                                  [y1, y2, y3, y4, y5, y6]]))
            # add a tri6 triangular element to the mesh
            triElements.append(elementDefinitions.tri6(vertices, tri, nu))

        self.elements = triElements  # store element list in mesh2D object

        # store the mesh arrays
        self.pointArray = pointArray
        self.elementArray = elementArray

        self.nu = nu  # poissons ratio of material
        self.noNodes = len(genMesh.points)  # total number of nodes in mesh

        # load results of geometricMesh
        if geometricMesh is not None:
            self.geometricMesh = geometricMesh
        else:
            self.geometricMesh = None

    # --------------------------------------------------------------------------
    # SECTION PROPERTY COMPUTATIONS:
    # --------------------------------------------------------------------------

    def computeGeometricProperties(self):
        '''
        This function computes the the geometric (warping independent) section
        properties for the mesh.
        '''
        # initialise variables
        totalArea = 0
        totalQx = 0
        totalQy = 0
        totalIxx_g = 0
        totalIyy_g = 0
        totalIxy_g = 0

        # loop through all the elements in the mesh
        for el in self.elements:
            # calculate geometric properties for each element
            ((elArea, elQx, elQy, elIxx_g, elIyy_g,
                elIxy_g)) = el.geometricProperties()

            # add element properties to global sum
            totalArea += elArea
            totalQx += elQx
            totalQy += elQy
            totalIxx_g += elIxx_g
            totalIyy_g += elIyy_g
            totalIxy_g += elIxy_g

        # ----------------------------------------------------------------------
        # GLOBAL xy AXIS PROPERTIES:
        # ----------------------------------------------------------------------

        # assign total area
        self.area = totalArea

        # assign first moments of area
        self.Qx = totalQx
        self.Qy = totalQy

        # calculate centroids
        self.cx = totalQy / totalArea
        self.cy = totalQx / totalArea

        # assign global axis second moments of area
        self.ixx_g = totalIxx_g
        self.iyy_g = totalIyy_g
        self.ixy_g = totalIxy_g

        # ----------------------------------------------------------------------
        # CENTROIDAL xy AXIS PROPERTIES:
        # ----------------------------------------------------------------------

        # calculate second moments of area about the centroidal xy axis
        self.ixx_c = totalIxx_g - totalQx ** 2 / totalArea
        self.iyy_c = totalIyy_g - totalQy ** 2 / totalArea
        self.ixy_c = totalIxy_g - totalQx * totalQy / totalArea

        # calculate section modulii about the centroidal xy axis
        self.centroidalSectionModulii()

        # calculate radii of gyration about centroidal xy axis
        self.rx_c = (self.ixx_c / totalArea) ** 0.5
        self.ry_c = (self.iyy_c / totalArea) ** 0.5

        # ----------------------------------------------------------------------
        # PRCINCIPAL AXIS PROPERTIES:
        # ----------------------------------------------------------------------

        # calculate prinicpal 2nd moments of area about the centroidal xy axis
        Delta = (((self.ixx_c - self.iyy_c) / 2) ** 2 + self.ixy_c ** 2) ** 0.5
        self.i11_c = (self.ixx_c + self.iyy_c) / 2 + Delta
        self.i22_c = (self.ixx_c + self.iyy_c) / 2 - Delta

        # calculate initial principal axis angle
        tol = 1e-9  # tolerance to avoid round off error when ixy << 1
        if abs(self.ixx_c - self.i11_c) < tol * self.i11_c:
            self.phi = 0
        else:
            self.phi = (np.arctan2(self.ixx_c - self.i11_c, self.ixy_c)
                        * 180 / np.pi)

        # calculate section modulii about the principal axis
        self.principalSectionModulii()

        # calculate radii of gyration about centroidal principal axis
        self.r1_c = (self.i11_c / totalArea) ** 0.5
        self.r2_c = (self.i22_c / totalArea) ** 0.5

    def computeGlobalPlasticProperties(self, points, facets, holes):
        '''
        This function computes the plastic centroid and plastic section modulii
        for global axis bending.
        '''
        tol = 1e-6  # plastic centroid algorithm convergence tolerance
        # unit vectors in the x & y directions
        ux = np.array([1, 0])
        uy = np.array([0, 1])

        # compute plastic centroids and plastic section modulii
        (x_a_n, topArea, botArea, topCentroidx, botCentroidx) = (pcAlgorithm(
            tol, 1000, uy, self.cx, self.cy, self.xmin - self.cx, self.xmax -
            self.cx, points, facets, holes, self.pointArray,
            self.elementArray, 1))
        (y_a_n, topArea, botArea, topCentroidy, botCentroidy) = (pcAlgorithm(
            tol, 1000, ux, self.cx, self.cy, self.ymin - self.cy, self.ymax -
            self.cy, points, facets, holes, self.pointArray,
            self.elementArray, 2))

        self.x_pc = self.cx + x_a_n
        self.y_pc = self.cy + y_a_n
        self.Sxx = self.area / 2 * abs(topCentroidy[1] - botCentroidy[1])
        self.Syy = self.area / 2 * abs(topCentroidx[0] - botCentroidx[0])

        # compute shape factors
        self.shapeFactor_xx_plus = self.Sxx / self.zxx_plus
        self.shapeFactor_xx_minus = self.Sxx / self.zxx_minus
        self.shapeFactor_yy_plus = self.Syy / self.zyy_plus
        self.shapeFactor_yy_minus = self.Syy / self.zyy_minus

    def computePrincipalPlasticProperties(self, points, facets, holes):
        '''
        This function computes the plastic centroid and plastic section modulii
        for principal axis bending.
        '''
        tol = 1e-6  # plastic centroid algorithm convergence tolerance
        # unit vectors in the 1 & 2 directions
        u1 = (np.array([np.cos(self.phi * np.pi / 180), np.sin(self.phi *
                                                               np.pi / 180)]))
        u2 = (np.array([-np.sin(self.phi * np.pi / 180), np.cos(self.phi *
                                                                np.pi / 180)]))

        # compute plastic centroids and plastic section modulii
        (x_1_a_n, topArea, botArea, topCentroid1, botCentroid1) = (pcAlgorithm(
            tol, 1000, -u1, self.cx, self.cy, self.y_2min, self.y_2max, points,
            facets, holes, self.pointArray, self.elementArray, 1))
        (y_2_a_n, topArea, botArea, topCentroid2, botCentroid2) = (pcAlgorithm(
            tol, 1000, -u2, self.cx, self.cy, self.x_1min, self.x_1max, points,
            facets, holes, self.pointArray, self.elementArray, 2))

        # calculate the area centroids in the principal coordinate system
        (tc1_1, tc1_2) = principalCoordinate(
            self.phi, topCentroid1[0] - self.cx, topCentroid1[1] - self.cy)
        (bc1_1, bc1_2) = principalCoordinate(
            self.phi, botCentroid1[0] - self.cx, botCentroid1[1] - self.cy)
        (tc2_1, tc2_2) = principalCoordinate(
            self.phi, topCentroid2[0] - self.cx, topCentroid2[1] - self.cy)
        (bc2_1, bc2_2) = principalCoordinate(
            self.phi, botCentroid2[0] - self.cx, botCentroid2[1] - self.cy)

        self.x_1_pc = self.cx + x_1_a_n * u2[0] + y_2_a_n * u1[0]
        self.y_2_pc = self.cy + x_1_a_n * u2[1] + y_2_a_n * u1[1]
        self.S11 = self.area / 2 * abs(tc1_2 - bc1_2)
        self.S22 = self.area / 2 * abs(tc2_1 - bc2_1)

        # compute shape factors
        self.shapeFactor_11_plus = self.S11 / self.z11_plus
        self.shapeFactor_11_minus = self.S11 / self.z11_minus
        self.shapeFactor_22_plus = self.S22 / self.z22_plus
        self.shapeFactor_22_minus = self.S22 / self.z22_minus

    def computeWarpingProperties(self, output=True):
        '''
        This function computes the the warping dependent section properties for
        the mesh. Boolean output configures whether or not output is printed to
        the console.
        '''
        # load areas and second moments of area from the geometricMesh
        A = self.geometricMesh.area
        ixx = self.geometricMesh.ixx_c
        iyy = self.geometricMesh.iyy_c
        ixy = self.geometricMesh.ixy_c
        phi = self.geometricMesh.phi

        # calculate stiffness matrix and load vector for warping function
        if output:
            processText = ('Assembling stiffness matrix ' +
                           'and torsion load vector...')
        else:
            processText = ''
        (shearK, torsionF) = (functionTimer(processText,
                                            self.assembleTorsionMatrices))

        # invert stiffness matrix using the lagrangian multipler method
        if output:
            processText = ('Inverting {} by {} stiffness matrix...'.format(
                shearK.shape[0], shearK.shape[0]))
        else:
            processText = ''
        invShearK = (functionTimer(processText,
                                   self.invertStiffnessMatrix, shearK))

        # ----------------------------------------------------------------------
        # TORSION PROPERTIES:
        # ----------------------------------------------------------------------

        # calculate warping constant and torsion constant
        self.omega = invShearK.dot(np.append(torsionF, 0))[:-1]
        self.J = (ixx + iyy - self.omega.dot(shearK).dot(np.transpose(
            self.omega)))

        # ----------------------------------------------------------------------
        # SHEAR PROPERTIES:
        # ----------------------------------------------------------------------

        # assemble shear force vectors, shear centre integrals and warping
        # moment integrals
        if output:
            processText = 'Assembling shear vectors and integrals...'
        else:
            processText = ''
        ((shearFPsi, shearFPhi, shearCentreXInt, shearCentreYInt, Q_omega,
            i_omega, i_xomega, i_yomega)) = (functionTimer(
                processText, self.assembleShearVectors, ixx, iyy, ixy))

        # solve for shear functions
        self.Psi = invShearK.dot(np.append(shearFPsi, 0))[:-1]
        self.Phi = invShearK.dot(np.append(shearFPhi, 0))[:-1]

        # calculate shear centres (elasticity approach)
        self.Delta_s = 2 * (1 + self.nu) * (ixx * iyy - ixy ** 2)
        self.x_se = ((1 / self.Delta_s) * ((self.nu / 2 * shearCentreXInt) -
                                           torsionF.dot(self.Phi)))
        self.y_se = ((1 / self.Delta_s) * ((self.nu / 2 * shearCentreYInt) +
                                           torsionF.dot(self.Psi)))
        (self.x_1_se, self.y_2_se) = principalCoordinate(
            phi, self.x_se, self.y_se)

        # calculate shear centres (Trefftz's approach)
        self.x_st = (ixy * i_xomega - iyy * i_yomega) / (ixx * iyy - ixy ** 2)
        self.y_st = (ixx * i_xomega - ixy * i_yomega) / (ixx * iyy - ixy ** 2)

        # calculate shear deformation coefficients
        if output:
            processText = 'Assembling shear deformation coefficients...'
        else:
            processText = ''

        (kappa_x, kappa_y, kappa_xy) = functionTimer(
            processText, self.assembleShearCoefficients, ixx, iyy, ixy)

        # calculate shear areas wrt global axis
        self.A_sx = self.Delta_s ** 2 / kappa_x
        self.A_sy = self.Delta_s ** 2 / kappa_y
        self.A_sxy = self.Delta_s ** 2 / kappa_xy

        # calculate shear areas wrt principal bending axis
        # calculate the shear coefficients (alpha) forming a 2nd order tensor
        alpha_xx = kappa_x * self.geometricMesh.area / self.Delta_s ** 2
        alpha_yy = kappa_y * self.geometricMesh.area / self.Delta_s ** 2
        alpha_xy = kappa_xy * self.geometricMesh.area / self.Delta_s ** 2
        # rotate the tensor by the principal axis angle
        phi_rad = self.geometricMesh.phi * np.pi / 180
        R = (np.array([[np.cos(phi_rad),  np.sin(phi_rad)],
                       [-np.sin(phi_rad), np.cos(phi_rad)]]))
        rotatedAlpha = R.dot(
            np.array([[alpha_xx, alpha_xy],
                      [alpha_xy, alpha_yy]])).dot(np.transpose(R))
        # recalculate the shear area based on the rotated alpha value
        self.A_s11 = self.geometricMesh.area / rotatedAlpha[0, 0]
        self.A_s22 = self.geometricMesh.area / rotatedAlpha[1, 1]

        # calculate warping constant
        self.Gamma = (i_omega - Q_omega ** 2 / A - self.y_se * i_xomega +
                      self.x_se * i_yomega)

    # --------------------------------------------------------------------------
    # SECTION PROPERTY METHODS:
    # --------------------------------------------------------------------------

    def invertStiffnessMatrix(self, K):
        '''
        This function inverts a stiffness matrix using the Lagrangian
        Multiplier method.
        '''
        Nvec1 = np.ones((K.shape[0], 1))  # column vector of ones
        Nvec2 = np.ones((1, K.shape[0] + 1))  # row vector of ones
        Nvec2[:, -1] = 0  # change last entry in row vector to a zero

        # build modified stiffness matrix: [K 1; 1 0]
        K = np.concatenate((K, Nvec1), axis=1)
        K = np.concatenate((K, Nvec2), axis=0)

        # invert the modified stiffness matrix
        return np.linalg.inv(K)

    def assembleTorsionMatrices(self):
        '''
        This function assembles the stiffness matrix to be used for warping
        problems, and also the torsion load vector.
        '''
        # initialise variables
        shearK = np.zeros((self.noNodes, self.noNodes))
        torsionF = np.zeros(self.noNodes)

        # loop through all elements in the mesh
        for el in self.elements:
            # indices to be used for matrix slicing
            indxs = np.ix_(el.nodes, el.nodes)
            # calculate the element stiffness matrix and torsion load vector
            (elK, elF) = el.torsionProperties()
            # assemble the local results into the global variables
            shearK[indxs] += elK
            torsionF[el.nodes] += elF

        return (shearK, torsionF)

    def assembleShearVectors(self, ixx, iyy, ixy):
        '''
        This function assembles load vectors to be used to solve for the shear
        functions, and also calculates integrals to be used in the calculation
        of the shear centre and the warping constant.
        '''
        # initialise variables
        shearFPsi = np.zeros(self.noNodes)
        shearFPhi = np.zeros(self.noNodes)
        shearCentreXInt = 0
        shearCentreYInt = 0
        Q_omega = 0
        i_omega = 0
        i_xomega = 0
        i_yomega = 0

        # loop through all elements in the mesh
        for el in self.elements:
            # calculate the element load vectors and variables
            ((elShearFPsi, elShearFPhi, elShearCentreXInt, elShearCentreYInt,
                elQ_omega, elI_omega, elI_xomega,
                elI_yomega)) = (el.shearProperties(ixx, iyy, ixy,
                                                   self.omega[el.nodes]))

            # assemble the local results into the global variables
            shearFPsi[el.nodes] += elShearFPsi
            shearFPhi[el.nodes] += elShearFPhi
            shearCentreXInt += elShearCentreXInt
            shearCentreYInt += elShearCentreYInt
            Q_omega += elQ_omega
            i_omega += elI_omega
            i_xomega += elI_xomega
            i_yomega += elI_yomega

        return ((shearFPsi, shearFPhi, shearCentreXInt, shearCentreYInt,
                 Q_omega, i_omega, i_xomega, i_yomega))

    def assembleShearCoefficients(self, ixx, iyy, ixy):
        '''
        This function assembles variables to be used to solve for the shear
        deformation coefficients, which in turn are used to calculate the
        shear areas.
        '''
        # initialise variables
        kappa_x = 0
        kappa_y = 0
        kappa_xy = 0

        # loop through all elements in the mesh
        for el in self.elements:
            # calculate the element variables
            (elKappa_x, elKappa_y, elKappa_xy) = el.shearCoefficients(
                ixx, iyy, ixy, self.Psi[el.nodes], self.Phi[el.nodes])

            # assemble the local results into the global variables
            kappa_x += elKappa_x
            kappa_y += elKappa_y
            kappa_xy += elKappa_xy

        return (kappa_x, kappa_y, kappa_xy)

    def computeAreaSegments(self, u, px, py):
        '''
        Computes the area above and below a line defined by unit vector u and
        point (px,py)
        '''
        # allocate area variables
        topArea = 0
        botArea = 0
        topQx = 0
        topQy = 0
        botQx = 0
        botQy = 0
        topCentroid = [0, 0]
        botCentroid = [0, 0]

        # loop through all elements in the mesh
        for el in self.elements:
            # calculate area of element and its first moments of area
            (elArea, Qx, Qy) = el.areaProperties()

            # if the element is not infinitessimally small
            if elArea != 0:
                # calculate the element centroid
                elCentroid = [Qy / elArea, Qx / elArea]
            else:
                elCentroid = [0, 0]

            # determine location of element and allocate element areas and
            # first moments of area accordingly
            if (pointAboveLine(u, px, py, elCentroid[0],
                               elCentroid[1])):
                topArea += elArea
                topQx += Qx
                topQy += Qy
            else:
                botArea += elArea
                botQx += Qx
                botQy += Qy

        # if the element is not infinitessimally small
        if topArea != 0 and botArea != 0:
            # calculate the centroid of the top and bottom areas
            topCentroid = np.array([topQy / topArea, topQx / topArea])
            botCentroid = np.array([botQy / botArea, botQx / botArea])

        return (topArea, botArea, topCentroid, botCentroid)

    def centroidalSectionModulii(self):
        '''
        This function calculates the elastic section modulii about the
        centroidal axis.
        '''
        # determine extreme values of the section in cartesian co-ordinates
        self.xmax = self.pointArray[:, 0].max()
        self.xmin = self.pointArray[:, 0].min()
        self.ymax = self.pointArray[:, 1].max()
        self.ymin = self.pointArray[:, 1].min()

        # evaluate section modulii
        self.zxx_plus = self.ixx_c / (self.ymax - self.cy)
        self.zxx_minus = self.ixx_c / (self.cy - self.ymin)
        self.zyy_plus = self.iyy_c / (self.xmax - self.cx)
        self.zyy_minus = self.iyy_c / (self.cx - self.xmin)

    def principalSectionModulii(self):
        '''
        This function calculates the elastic section modulii about the
        principal axis.
        '''
        # loop through all points in the mesh
        for (i, vertex) in enumerate(self.pointArray):
            # determine the coordinate of the point wrt the principal axis
            (x_1, y_2) = (principalCoordinate(self.phi, vertex[0] -
                                              self.cx, vertex[1] - self.cy))

            # initialise min, max variables
            if i == 0:
                self.x_1max = x_1
                self.x_1min = x_1
                self.y_2max = y_2
                self.y_2min = y_2

            # update the mins and maxs where necessary
            self.x_1max = max(self.x_1max, x_1)
            self.x_1min = min(self.x_1min, x_1)
            self.y_2max = max(self.y_2max, y_2)
            self.y_2min = min(self.y_2min, y_2)

        # evaluate principal section modulii
        self.z11_plus = self.i11_c / abs(self.y_2max)
        self.z11_minus = self.i11_c / abs(self.y_2min)
        self.z22_plus = self.i22_c / abs(self.x_1max)
        self.z22_minus = self.i22_c / abs(self.x_1min)

    # --------------------------------------------------------------------------
    # STRESS CALCULATION:
    # --------------------------------------------------------------------------

    def unitStress(self, output=True):
        '''
        Helper function to enable timing of the calculateStress function.
        Boolean output configures whether or not output is printed to the
        console.
        '''
        # calculate stresses due to unit loading
        if output:
            processText = 'Calculating cross-section stresses...'
        else:
            processText = ''
        functionTimer(processText, self.calculateStress)

    def calculateStress(self):
        '''
        This function calculates the cross-section stresses as a result of unit
        loading (axial, moment, shear, torsion).
        '''
        # load geometric propeties from the geometricMesh
        area = self.geometricMesh.area
        ixx = self.geometricMesh.ixx_c
        iyy = self.geometricMesh.iyy_c
        ixy = self.geometricMesh.ixy_c
        i11 = self.geometricMesh.i11_c
        i22 = self.geometricMesh.i22_c
        phi = self.geometricMesh.phi

        # allocate stress vectors
        self.sigma_zz_axial = np.zeros(self.noNodes)
        self.sigma_zz_bending_xx = np.zeros(self.noNodes)
        self.sigma_zz_bending_yy = np.zeros(self.noNodes)
        self.sigma_zz_bending_11 = np.zeros(self.noNodes)
        self.sigma_zz_bending_22 = np.zeros(self.noNodes)
        self.tau_zx_torsion = np.zeros(self.noNodes)
        self.tau_zy_torsion = np.zeros(self.noNodes)
        self.tau_zx_shear_x = np.zeros(self.noNodes)
        self.tau_zy_shear_x = np.zeros(self.noNodes)
        self.tau_zx_shear_y = np.zeros(self.noNodes)
        self.tau_zy_shear_y = np.zeros(self.noNodes)

        # allocate nodal count vector for nodal averaging
        node_count = np.zeros(self.noNodes)

        # loop through all elements in the mesh
        for el in self.elements:
            # evaluate stresses at nodes
            (elSigma_zz_axial, elSigma_zz_bending_xx, elSigma_zz_bending_yy,
                elSigma_zz_bending_11, elSigma_zz_bending_22, elTau_zx_torsion,
                elTau_zy_torsion, elTau_shear_zx_x, elTau_shear_zy_x,
                elTau_shear_zx_y, elTau_shear_zy_y) = el.calculateStress(
                area, ixx, iyy, ixy, i11, i22, phi, self.omega[el.nodes],
                self.J, self.Psi[el.nodes], self.Phi[el.nodes], self.Delta_s)

            # add stresses to global vectors
            self.sigma_zz_axial[el.nodes] += elSigma_zz_axial[:, 0]
            self.sigma_zz_bending_xx[el.nodes] += elSigma_zz_bending_xx
            self.sigma_zz_bending_yy[el.nodes] += elSigma_zz_bending_yy
            self.sigma_zz_bending_11[el.nodes] += elSigma_zz_bending_11
            self.sigma_zz_bending_22[el.nodes] += elSigma_zz_bending_22
            self.tau_zx_torsion[el.nodes] += elTau_zx_torsion
            self.tau_zy_torsion[el.nodes] += elTau_zy_torsion
            self.tau_zx_shear_x[el.nodes] += elTau_shear_zx_x
            self.tau_zy_shear_x[el.nodes] += elTau_shear_zy_x
            self.tau_zx_shear_y[el.nodes] += elTau_shear_zx_y
            self.tau_zy_shear_y[el.nodes] += elTau_shear_zy_y

            # increment the nodal count vector
            node_count[el.nodes] += 1

        # nodal averaging
        self.sigma_zz_axial *= 1 / node_count
        self.sigma_zz_bending_xx *= 1 / node_count
        self.sigma_zz_bending_yy *= 1 / node_count
        self.sigma_zz_bending_11 *= 1 / node_count
        self.sigma_zz_bending_22 *= 1 / node_count
        self.tau_zx_torsion *= 1 / node_count
        self.tau_zy_torsion *= 1 / node_count
        self.tau_zx_shear_x *= 1 / node_count
        self.tau_zy_shear_x *= 1 / node_count
        self.tau_zx_shear_y *= 1 / node_count
        self.tau_zy_shear_y *= 1 / node_count

    def evaluateSectionStress(self, Nzz, Mxx, Myy, M11, M22, Mzz, Vx, Vy):
        '''
        This function scales the results obtained from the calculateStress
        function by the design actions specified as input.
        '''
        # scale unit stresses by design actions
        self.axialStress = self.sigma_zz_axial * Nzz
        self.bendingStress = (self.sigma_zz_bending_xx * Mxx +
                              self.sigma_zz_bending_yy * Myy +
                              self.sigma_zz_bending_11 * M11 +
                              self.sigma_zz_bending_22 * M22)
        self.torsionStress_zx = self.tau_zx_torsion * Mzz
        self.torsionStress_zy = self.tau_zy_torsion * Mzz
        self.torsionStress = ((self.torsionStress_zx ** 2 +
                               self.torsionStress_zy ** 2) ** 0.5)
        self.shearStress_zx = (self.tau_zx_shear_x * Vx +
                               self.tau_zx_shear_y * Vy)
        self.shearStress_zy = (self.tau_zy_shear_x * Vx +
                               self.tau_zy_shear_y * Vy)
        self.shearStress = ((self.shearStress_zx ** 2 +
                             self.shearStress_zy ** 2) ** 0.5)

        # compute combined stresses
        self.sigma_zz = self.axialStress + self.bendingStress
        self.tau_zx = self.torsionStress_zx + self.shearStress_zx
        self.tau_zy = self.torsionStress_zy + self.shearStress_zy
        self.tau = (self.tau_zx ** 2 + self.tau_zy ** 2) ** 0.5
        self.vonMises = ((self.sigma_zz ** 2 + 3 * (self.tau ** 2)) ** 0.5)

    # --------------------------------------------------------------------------
    # POST-PROCESSING METHODS:
    # --------------------------------------------------------------------------

    def contourPlot(self, principalAxis=False, z=None, nodes=False,
                    plotTitle='', centroids=False):
        '''
        This function generates a plot of the mesh with an optional contour
        plot of results (z). Additional options include displaying the nodes, a
        plot title, and for warping results only, the principal axis and
        centroids.
        '''
        # ensure plot is not skewed
        plt.gca().set_aspect('equal')
        # plot the mesh
        (plt.triplot(self.pointArray[:, 0], self.pointArray[:, 1],
                     self.elementArray[:, 0:3], lw=0.5, color='black'))
        # plot the title and axis labels
        plt.title(plotTitle)
        plt.xlabel('x')
        plt.ylabel('y')

        # plot the principal axis as lines
        if principalAxis:
            start_11 = (globalCoordinate(self.geometricMesh.phi,
                                         self.geometricMesh.x_1min, 0))
            end_11 = (globalCoordinate(self.geometricMesh.phi,
                                       self.geometricMesh.x_1max, 0))
            start_22 = (globalCoordinate(self.geometricMesh.phi,
                                         0, self.geometricMesh.y_2min))
            end_22 = (globalCoordinate(self.geometricMesh.phi, 0,
                                       self.geometricMesh.y_2max))

            (plt.plot([start_11[0], end_11[0]], [start_11[1], end_11[1]],
                      label='11 axis'))
            (plt.plot([start_22[0], end_22[0]], [start_22[1], end_22[1]],
                      label='22 axis'))

        # plot the locations of the various centroids
        if centroids:
            plt.scatter(0, 0, facecolors='None', edgecolors='k', marker='o',
                        s=100, label='Elastic Centroid')
            plt.scatter(self.geometricMesh.x_pc - self.geometricMesh.cx,
                        self.geometricMesh.y_pc - self.geometricMesh.cy, c='k',
                        marker='x', s=100, label='Global Plastic Centroid')
            plt.scatter(self.geometricMesh.x_1_pc - self.geometricMesh.cx,
                        self.geometricMesh.y_2_pc - self.geometricMesh.cy,
                        facecolors='None', edgecolors='k', marker='s', s=100,
                        label='Principal Plastic Centroid')
            plt.scatter(self.x_se, self.y_se, c='k', marker='+', s=100,
                        label='Shear Centre')
            plt.legend()

        # plot a contour of results defined by z
        if z is not None:
            cmap = cm.get_cmap(name='jet')

            # if values are not all constant
            if np.amax(z) - np.amin(z) > 1e-6:
                v = np.linspace(np.amin(z), np.amax(z), 10, endpoint=True)
            else:
                # ten contours
                v = 10

            trictr = plt.tricontourf(
                self.pointArray[:, 0], self.pointArray[:, 1],
                self.elementArray[:, 0:3], z, v, cmap=cmap)
            cbar = plt.colorbar(trictr, label='Stress')

        # show the nodes
        if nodes:
            (plt.plot(self.pointArray[:, 0], self.pointArray[:, 1], 'ko',
                      markersize=1))

        plt.grid(True)
        plt.show()

    def quiverPlot(self, u, v, plotTitle=''):
        '''
        This function produces a quiver plot of a vector with componenets u and
        v, overlaid with the mesh.
        '''
        plt.figure()
        plt.gca().set_aspect('equal')
        # plot the mesh
        (plt.triplot(self.pointArray[:, 0], self.pointArray[:, 1],
                     self.elementArray[:, 0:3], lw=0.5, color='black'))
        # plot the title and axis labels
        plt.title(plotTitle)
        plt.xlabel('x')
        plt.ylabel('y')

        # scale the colour with respect to the magnitude of the vector
        c = np.hypot(u, v)
        cmap = cm.get_cmap(name='jet')
        # generate the quiver plot and apply the colourbar
        if np.amin(c) != np.amax(c):
            # only show the quiver plot if there are results
            quiv = (plt.quiver(self.pointArray[:, 0], self.pointArray[:, 1], u,
                               v, c, cmap=cmap))
            v1 = np.linspace(np.amin(c), np.amax(c), 10, endpoint=True)
            cbar = plt.colorbar(quiv, label='Stress', ticks=v1)

        plt.grid(True)
        plt.show()

    def printGeometricResults(self):
        '''
        This function prints the results of the geometric cross-sectional
        analaysis to the console.
        '''
        print "-------------------------"
        print "Global xy Axis Properties"
        print "-------------------------"
        print "Area = {}".format(self.area)
        print "Qx = {}".format(self.Qx)
        print "Qy = {}".format(self.Qy)
        print "cx = {}".format(self.cx)
        print "cy = {}".format(self.cy)
        print "Ixx_g = {}".format(self.ixx_g)
        print "Iyy_g = {}".format(self.iyy_g)
        print "Ixy_g = {}".format(self.ixy_g)
        print ""
        print "-----------------------------"
        print "Centroidal xy Axis Properties"
        print "-----------------------------"
        print "Ixx_c = {}".format(self.ixx_c)
        print "Iyy_c = {}".format(self.iyy_c)
        print "Ixy_c = {}".format(self.ixy_c)
        print "Zxx+ = {}".format(self.zxx_plus)
        print "Zxx- = {}".format(self.zxx_minus)
        print "Zyy+ = {}".format(self.zyy_plus)
        print "Zyy- = {}".format(self.zyy_minus)
        print "rx_c = {}".format(self.rx_c)
        print "ry_c = {}".format(self.ry_c)
        print ""
        print "-----------------------------"
        print "Principal Axis Properties"
        print "-----------------------------"
        print "phi = {}".format(self.phi)
        print "I11_c = {}".format(self.i11_c)
        print "I22_c = {}".format(self.i22_c)
        print "Z11+ = {}".format(self.z11_plus)
        print "Z11- = {}".format(self.z11_minus)
        print "Z22+ = {}".format(self.z22_plus)
        print "Z22- = {}".format(self.z22_minus)
        print "r1_c = {}".format(self.r1_c)
        print "r2_c = {}".format(self.r2_c)
        print ""

    def printPlasticResults(self):
        '''
        This function prints the results of the plastic section analaysis to
        the console.
        '''
        print "-----------------------------"
        print "Plastic Properties"
        print "-----------------------------"
        print "x_pc = {}".format(self.x_pc)
        print "y_pc = {}".format(self.y_pc)
        print "Sxx = {}".format(self.Sxx)
        print "Syy = {}".format(self.Syy)
        print "SF_xx+ = {}".format(self.shapeFactor_xx_plus)
        print "SF_xx- = {}".format(self.shapeFactor_xx_minus)
        print "SF_yy+ = {}".format(self.shapeFactor_yy_plus)
        print "SF_yy- = {}".format(self.shapeFactor_yy_minus)
        print "x_1_pc = {}".format(self.x_1_pc)
        print "y_2_pc = {}".format(self.y_2_pc)
        print "S11 = {}".format(self.S11)
        print "S22 = {}".format(self.S22)
        print "SF_11+ = {}".format(self.shapeFactor_11_plus)
        print "SF_11- = {}".format(self.shapeFactor_11_minus)
        print "SF_22+ = {}".format(self.shapeFactor_22_plus)
        print "SF_22- = {}".format(self.shapeFactor_22_minus)
        print ""

    def printWarpingResults(self):
        '''
        This function prints the results of the warping dependent
        cross-sectional analaysis to the console.
        '''
        print "-----------------------------"
        print "Torsional Properties"
        print "-----------------------------"
        print "J = {}".format(self.J)
        print "Iw = {}".format(self.Gamma)
        print ""
        print "-----------------------------"
        print "Shear Properties"
        print "-----------------------------"
        print "x_s,e = {}".format(self.x_se)
        print "y_s,e = {}".format(self.y_se)
        print "x_s,t = {}".format(self.x_st)
        print "y_s,t = {}".format(self.y_st)
        print "x_1_s,e = {}".format(self.x_1_se)
        print "y_2_s,e = {}".format(self.y_2_se)
        print "A_s,x = {}".format(self.A_sx)
        print "A_s,y = {}".format(self.A_sy)
        print "A_s,11 = {}".format(self.A_s11)
        print "A_s,22 = {}".format(self.A_s22)
        print ""

# ------------------------------------------------------------------------------
# GENERAL METHODS:
# ------------------------------------------------------------------------------


def pcAlgorithm(tol, maxIt, u, cx, cy, dmin, dmax, points, facets, holes,
                pointArray, elementArray, dir):
    '''
    Algorithm to find plastic centroid (point at which top area = bot area):
        INPUT:
        tol = convergence tolerance
        maxIt = maximum iterations
        u = unit vector in direction of axis
        (cx,cy) = centroid of section
        start = initial guess of the plastic axis location
        (dmin,dmax) = distance from centroid to extreme fibre of section
        points = input points list
        facets = input facets list
        holes = input holes list
        pointArray = np array containing mesh points
        elementArray = np array containing element vertices
        dir = 1 or 2 depending on axis direction (x or y; 11 or 22)

        OUTPUT:
        a_n = perpendicular distance from centroid to p.c.
    '''
    # initialise iteration variables
    areaConvergence_n = 0
    a_n1 = 0
    iterationCount = 1
    if (dir == 1):
        u_perp = np.array([u[1], -u[0]])  # u vector rotated  -90 degrees
    elif (dir == 2):
        u_perp = np.array([-u[1], u[0]])  # u vector rotated  90 degrees

    # algorithm
    while ((abs(areaConvergence_n) > tol or iterationCount < 3) and
           (iterationCount < maxIt)):
        if iterationCount < 3:
            # first two to setup secant method
            a_n = (np.random.rand() - 0.5) * 0.2 * (dmax - dmin)
        else:
            # secant method
            a_n = ((a_n2 * areaConvergence_n - a_n1 * areaConvergence_n1) /
                   (areaConvergence_n - areaConvergence_n1))

        # console reporting for debugging purposes
        # print 'a_n = {}'.format(a_n)
        # print 'dmin = {}'.format(dmin)
        # print 'dmax = {}'.format(dmax)

        # ensure trial axis is within section depth
        if a_n > dmax:
            a_n = 0.9 * dmax
        elif a_n < dmin:
            a_n = 0.9 * dmin

        # determine points (p1,p2) on trial axis
        p1 = np.array([cx + a_n * u_perp[0], cy + a_n * u_perp[1]])
        p2 = np.array([p1[0] + u[0], p1[1] + u[1]])

        # remesh with new trial axis included
        (points_new, facets_new) = divideMesh(
            points[:], facets[:], pointArray, elementArray,
            p1[0], p1[1], p2[0], p2[1])
        newMesh = femFunctions.createMesh(
            points_new, facets_new, holes, minAngle=None, qualityMeshing=False)

        # create triMesh object with new trial mesh
        meshTrial = triMesh(newMesh)
        # meshTrial.contourPlot(nodes=True) # plot for debugging purposes

        # calculate area above and below axis
        (topArea, botArea, topCentroid, botCentroid) = \
            meshTrial.computeAreaSegments(u, p1[0], p1[1])

        # update convergence and solution data
        areaConvergence_n1 = areaConvergence_n
        areaConvergence_n = topArea / botArea - 1
        # console reporting for debugging purposes
        # print 'convergence = {}'.format(areaConvergence_n)
        # print '---'

        # update solution variables and increment the counter
        a_n2 = a_n1
        a_n1 = a_n
        iterationCount += 1

    if (abs(areaConvergence_n) > tol):
        text1 = 'WARNING: Plastic centroid algorithm did not converge for the '
        text2 = 'axis in the direction x:{0:.3f}; y:{1:.3f}'.format(u[0], u[1])
        print text1 + text2 + '\n'

    return (a_n, topArea, botArea, topCentroid, botCentroid)


def shiftGeometry(points, holes, x, y):
    '''
    This function shifts the points and holes for the geometry input by a
    defined offset in x and y.
    '''
    # initialise shifted points and holes lists
    shiftedPoints = []
    shiftedHoles = []

    # shift points by x and y
    for point in points:
        shiftedPoints.append((point[0] - x, point[1] - y))

    for hole in holes:
        shiftedHoles.append((hole[0] - x, hole[1] - y))

    return (shiftedPoints, shiftedHoles)


def divideMesh(points, facets, pointArray, elementArray, x1, y1, x2, y2):
    '''
    This function loops through each facet to check for an intersection point
    with the line defined by (x1,y1) and (x2,y2). If so, adds a point to the
    mesh and then adds facets between the added points if the line is within
    the mesh domain (and not within a hole).
    '''
    # allocate lists for intersection points
    xIntPoints = []
    yIntPoints = []
    facetIntersections = []
    facetIndices = []

    numPoints = len(points)  # number of points in the geometry

    # calculate intersection points using determinant approach
    # determine values governed by (x1,y1) & (x2,y2) only
    numerator_11 = x1 * y2 - y1 * x2

    for (i, line) in enumerate(facets):
        # start and end points of the current facet
        x3 = points[line[0]][0]
        y3 = points[line[0]][1]
        x4 = points[line[1]][0]
        y4 = points[line[1]][1]
        # tolerance to account for rounding errors in intersection calculation
        tol = 1e-12 * max(abs(x4 - x3), abs(y4 - y3))

        # calculate denominator for determinant approach
        den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

        # check to see if there is an intersection
        if den != 0:
            # determine remaining values
            numerator_21 = x3 * y4 - y3 * x4

            # determine intersection points
            xInt = (numerator_11 * (x3 - x4) - (x1 - x2) * numerator_21) / den
            yInt = (numerator_11 * (y3 - y4) - (y1 - y2) * numerator_21) / den

            # check to see if points lie within extents of facet
            if (min(x3, x4) - tol <= xInt <= max(x3, x4) + tol and
                    min(y3, y4) - tol <= yInt <= max(y3, y4) + tol):

                # check to see if point already added
                isAdded = False
                for (j, xloc) in enumerate(xIntPoints):
                    if xloc == xInt and yIntPoints[j] == yInt:
                        isAdded = True

                if isAdded is False:
                    # zip nodes
                    if abs(xInt - x3) < tol:
                        xInt = x3
                    elif abs(xInt - x4) < tol:
                        xInt = x4
                    if abs(yInt - y3) < tol:
                        yInt = y3
                    elif abs(yInt - y4) < tol:
                        yInt = y4

                    # add point to intersection list
                    xIntPoints.append(xInt)
                    yIntPoints.append(yInt)
                    # add facet to intersection list
                    facetIndices.append(i)

    # sort intersection lists and facet list based on x or y value
    if len(xIntPoints) > 0:
        if x1 == x2:
            # sort by y
            (yIntPoints, xIntPoints, facetIndices) = (list(t) for t in zip(
                *sorted(zip(yIntPoints, xIntPoints, facetIndices))))
        else:
            # sort by x
            (xIntPoints, yIntPoints, facetIndices) = (list(t) for t in zip(
                *sorted(zip(xIntPoints, yIntPoints, facetIndices))))

    # loop through all found intersection points
    for (i, pt) in enumerate(xIntPoints):
        # add intersection points to geometry point list
        points.append((pt, yIntPoints[i]))
        # add index of new point to the facetIntersections list
        facetIntersections.append(i)

        # add connecting facets to facet list
        if i != 0:  # start by joining new point 2 to new point 1
            # check to see if midpoint of facet lies within an element of mesh,
            # i.e. we are not in a hole
            px = 0.5 * (xIntPoints[i] + xIntPoints[i - 1])
            py = 0.5 * (yIntPoints[i] + yIntPoints[i - 1])
            facetInDomain = False
            # loop through all elements in mesh
            for tri in elementArray:
                x1 = pointArray[tri[0]][0]
                y1 = pointArray[tri[0]][1]
                x2 = pointArray[tri[1]][0]
                y2 = pointArray[tri[1]][1]
                x3 = pointArray[tri[2]][0]
                y3 = pointArray[tri[2]][1]

                # compute variables alpha, beta, gamma, to determine if current
                # point lies within the triangular element
                alpha = (((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) /
                         ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3)))
                beta = (((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) /
                        ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3)))
                gamma = 1.0 - alpha - beta

                # if the point lies within an element
                if alpha >= 0 and beta >= 0 and gamma >= 0:
                    facetInDomain = True
                    break  # break out of current loop

            if facetInDomain:
                # add connecting facet along line of interest
                facets.append((numPoints + i - 1, numPoints + i))

    newFacets = []  # allocate new facet list

    # loop through all facets to reconstruct facet list and subdivide facets
    # at all intersection points
    for (i, facet) in enumerate(facets):
        # assume that the facet has already been added (either in the original
        # geometry, or added in the previous loop)
        facetOriginal = True

        # loop through all newly added facets
        for (counter, j) in enumerate(facetIndices):
            # if the current facet is being interesected with a new facet
            if i == j:
                # subdivide this current facet into two facets
                (newFacets.append((facet[0], numPoints +
                                   facetIntersections[counter])))
                (newFacets.append((numPoints + facetIntersections[counter],
                                   facet[1])))
                facetOriginal = False

        # if it's an original facet, add to new list
        if facetOriginal:
            newFacets.append((facet[0], facet[1]))

    # plotGeometry(points, newFacets, []) # plot for debugging purposes

    return (points, newFacets)


def principalCoordinate(phi, x, y):
    '''
    This function determines the coordinates of the cartesian point (x,y) in
    the principal axis system given an axis rotation angle phi.
    '''
    # convert principal axis angle to radians
    phi_rad = phi * np.pi / 180
    # form rotation matrix
    R = (np.array([[np.cos(phi_rad), np.sin(phi_rad)], [-np.sin(phi_rad),
                                                        np.cos(phi_rad)]]))
    # calculate rotated x and y coordinates
    x_rotated = R.dot(np.array([x, y]))

    return (x_rotated[0], x_rotated[1])


def globalCoordinate(phi, x_1, y_2):
    '''
    This function determines the coordinates of the point (x_1,y_2) in the
    global axis system given rotation phi.
    '''
    # convert principal axis angle to radians
    phi_rad = phi * np.pi / 180
    # form transposed rotation matrix
    R = (np.array([[np.cos(phi_rad), -np.sin(phi_rad)], [np.sin(phi_rad),
                                                         np.cos(phi_rad)]]))
    # calculate rotated x_1 and y_2 coordinates
    x_rotated = R.dot(np.array([x_1, y_2]))

    return (x_rotated[0], x_rotated[1])


def pointAboveLine(u, px, py, x, y):
    '''
    This function determines whether a point (x,y) is a above or below a line
    defined by unit vector u and point (px,py).
    '''
    # vector from point to point on line
    PQ = np.array([px - x, py - y])
    return np.cross(PQ, u) > 0


def plotGeometry(points, facets, holes):
    '''
    This function plots the geometry defined by points, facets and holes.
    '''
    plt.gca().set_aspect('equal')
    # plot the title and axis labels
    plt.title('Input Geometry')
    plt.xlabel('x')
    plt.ylabel('y')

    for facet in facets:
        # plot the facets
        plt.plot([points[facet[0]][0], points[facet[1]][0]],
                 [points[facet[0]][1], points[facet[1]][1]],
                 'ko-', markersize=2)

    for hole in holes:
        # plot the holes
        plt.plot(hole[0], hole[1], 'rx', markerSize=5)

    plt.grid(True)
    plt.show()


def functionTimer(text, function, *args):
    '''
    This function displays the message 'text' and returns the time taken for a
    function, with arguments args, to execute. The value returned by the
    timed function is also returned
    '''
    start_time = time.time()
    if text != '':
        print text
    result = function(*args)
    if text != '':
        print("--- %s completed in %s seconds ---" % (
            function.__name__, time.time() - start_time))
        print ''
    return result
